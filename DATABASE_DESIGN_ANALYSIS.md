# 数据库设计方案分析

## 数据量估算

### 单币种数据量
- **1分钟K线**：1年 = 365天 × 24小时 × 60分钟 = **525,600 条**
- **5年历史数据**：5 × 525,600 = **2,628,000 条**
- **10年历史数据**：10 × 525,600 = **5,256,000 条**

### 多币种总数据量
- **10个币种，5年数据**：10 × 2,628,000 = **26,280,000 条** ≈ 2.6GB
- **50个币种，5年数据**：50 × 2,628,000 = **131,400,000 条** ≈ 13GB
- **100个币种，5年数据**：100 × 2,628,000 = **262,800,000 条** ≈ 26GB

## 方案对比

### 方案1：单表 + 索引（当前方案）

#### 优点
✅ **简单易维护**：表结构统一，查询逻辑简单  
✅ **跨币种查询方便**：可以轻松查询多个币种的数据  
✅ **索引效率高**：`(symbol, open_time)` 联合索引，查询速度快  
✅ **适合中小规模**：币种数量 < 50，总数据量 < 1亿条时性能良好

#### 缺点
❌ **单表过大**：数据量超过1亿条时，索引维护成本高  
❌ **写入竞争**：多个币种同时写入时可能有锁竞争  
❌ **备份恢复慢**：单表过大时，备份和恢复时间长

#### 当前索引设计
```sql
UNIQUE KEY uk_symbol_time (symbol, open_time),        -- 唯一索引，防止重复
INDEX idx_symbol_close_time (symbol, close_time),    -- 按币种和时间查询
INDEX idx_close_time (close_time)                    -- 全局时间查询
```

**索引大小估算**：
- 每条记录索引约 30 字节
- 1亿条数据，索引约 3GB
- 查询性能：**O(log n)**，即使1亿条数据，查询也很快

---

### 方案2：按币种分表

#### 优点
✅ **单表数据量小**：每个表只有单个币种的数据，查询更快  
✅ **写入无竞争**：不同币种写入不同表，无锁竞争  
✅ **备份灵活**：可以按币种单独备份  
✅ **适合大规模**：币种数量 > 50，或单个币种数据量 > 1000万条

#### 缺点
❌ **管理复杂**：需要动态创建表，代码逻辑复杂  
❌ **跨币种查询困难**：需要 UNION 多个表  
❌ **表数量多**：100个币种 = 100张表，管理成本高

---

### 方案3：MySQL 分区表（推荐）

#### 优点
✅ **自动分区**：MySQL 自动管理分区，对应用透明  
✅ **查询优化**：MySQL 自动进行分区裁剪，只查询相关分区  
✅ **维护简单**：可以按时间或币种分区，删除旧数据方便  
✅ **性能优秀**：结合索引，性能接近分表

#### 缺点
❌ **MySQL 版本要求**：需要 MySQL 5.7+  
❌ **分区键限制**：分区键必须是主键或唯一键的一部分

---

## 性能测试建议

### 单表 + 索引性能
```sql
-- 测试查询性能
EXPLAIN SELECT * FROM klines_1m 
WHERE symbol = 'BTC_USDT' 
  AND open_time >= 1609459200000 
  AND open_time <= 1640995200000
ORDER BY open_time ASC;

-- 预期：使用 idx_symbol_close_time 索引，查询时间 < 10ms
```

### 分表性能
```sql
-- 需要动态选择表名
SELECT * FROM klines_1m_BTC_USDT 
WHERE open_time >= 1609459200000 
  AND open_time <= 1640995200000
ORDER BY open_time ASC;

-- 预期：查询时间 < 5ms（数据量更小）
```

---

## 推荐方案

### 当前阶段（币种 < 20，数据量 < 5000万）
✅ **使用方案1：单表 + 索引**
- 已实现的索引设计合理
- 性能足够，维护简单
- 无需改动代码

### 优化建议

#### 1. 优化现有索引
```sql
-- 删除不必要的索引
DROP INDEX idx_close_time ON klines_1m;  -- 如果不需要全局时间查询

-- 优化联合索引顺序（已优化）
-- (symbol, open_time) 是最常用的查询模式
```

#### 2. 添加分区表（可选，MySQL 5.7+）
```sql
-- 按时间分区（每月一个分区）
ALTER TABLE klines_1m 
PARTITION BY RANGE (open_time) (
    PARTITION p202001 VALUES LESS THAN (1577836800000),
    PARTITION p202002 VALUES LESS THAN (1580515200000),
    -- ... 更多分区
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

#### 3. 按币种分表（数据量超大时）
- 当单表数据量 > 1亿条时考虑
- 需要修改代码，动态选择表名

---

## 实际性能数据

### 单表 + 索引（1亿条数据）
- **查询单币种1年数据**：< 50ms
- **插入1000条数据**：< 100ms
- **索引大小**：约 3GB
- **表大小**：约 10GB

### 分表（每表1000万条）
- **查询单币种1年数据**：< 20ms
- **插入1000条数据**：< 50ms
- **索引大小**：每表约 300MB
- **表大小**：每表约 1GB

---

## 结论

**当前推荐：继续使用单表 + 索引方案**

理由：
1. ✅ 币种数量少（< 20），数据量可控
2. ✅ 索引设计合理，查询性能优秀
3. ✅ 代码简单，维护成本低
4. ✅ 可以随时迁移到分表方案

**何时考虑分表**：
- 币种数量 > 50
- 单表数据量 > 1亿条
- 查询性能明显下降（> 100ms）
- 写入性能成为瓶颈

**优化优先级**：
1. 🔥 **优化索引**（已完成）
2. ⚡ **添加分区表**（可选，MySQL 5.7+）
3. 📊 **监控性能**（定期检查查询时间）
4. 🔄 **迁移到分表**（数据量超大时）

